/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.8.0
 * Fri, 18 Jul 2025 20:35:56 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    function generateUniqueName(name, isUniqueCb) {
        let uniqueName = name;
    
        if (isUniqueCb !== undefined) {
            while (!isUniqueCb(uniqueName)) {
                const r = uniqueName.match(/^(.*?)(\d+)$/);
                if (!r) {
                    uniqueName += '2';
                } else {
                    uniqueName = r[1] + (Number.parseInt(r[2], 10) + 1);
                }
            }
        }
    
        return uniqueName;
    }
        
    function generateUniqueObjectName(name) {
        return generateUniqueName(name, name => !Boolean(getObjectByName(name)));
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }

    return {
        transformCoordsSpace, getSceneCoordSystem, getObjectByName, generateUniqueObjectName,
        retrieveObjectNames,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["3d"] = my_3d;
this.procedures["izquierda"] = izquierda;
this.procedures["derecha"] = derecha;

var PROC = {
    "3d": my_3d,
    "izquierda": izquierda,
    "derecha": derecha,
};

var VARS = Object.defineProperties({}, {
    'carru': { get: function() { return carru; }, set: function(val) { carru = val; } },
});

var carru;

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// addFog puzzle
function addFog(r, g, b, density, near, far) {

    var color = _pGlob.colorTmp.setRGB(r, g, b);

    if (density >= 0)
        appInstance.scene.fog = new v3d.FogExp2(color, density);
    else
        appInstance.scene.fog = new v3d.Fog(color, near, far);
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// addAnnotation and removeAnnotation puzzles
function handleAnnot(add, annot, objSelector, contents, id, name) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        // check if it already has an annotation and remove it
        for (var j = 0; j < obj.children.length; j++) {
            var child = obj.children[j];
            if (child.type == "Annotation") {
                // delete all childs of annotation
                child.traverse(function(child2) {
                    if (child2.isAnnotation)
                        child2.dispose();
                    });
                obj.remove(child);
            }
        }
        if (add) {
            var aObj = new v3d.Annotation(appInstance.container, annot, contents);
            aObj.name = PzLib.generateUniqueObjectName(name ? name : annot);
            aObj.fadeObscured = _pGlob.fadeAnnotations;
            if (id) {
                aObj.annotation.id = id;
                aObj.annotationDialog.id = id+'_dialog';
            }
            obj.add(aObj);
        }
    }
}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// Describe this function...
function my_3d() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-inspeccion").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-fluidos").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-imagenes").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-aceite").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-transmision").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-refrigerante").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-hidraulico").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-frenos").style.display = "none";' + '\n' +
  'document.getElementById("cuadro-filtroaire").style.display = "none";' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);

  handleAnnot(false, '', ['ALL_OBJECTS'], '', '', undefined);
  outline(['ALL_OBJECTS'], 'DISABLE');
  registerSetTimeout(0.2, function() {
    if (carru == 0) {
    } else if (carru == 1) {
      handleAnnot(true, 'Mastil', 'MÁSTIL DE MONTACARGAS', '1', '1', undefined);
      tweenCamera('', '16. Mástil', 1, function() {}, 0);
      outline('16. Mástil', 'ENABLE');
    } else if (carru == 2) {
      handleAnnot(true, 'Cuchillas.', '13. Horquilla', '1', '2', undefined);
      tweenCamera('', '13. Horquilla', 1, function() {}, 0);
      outline('orquilla2', 'ENABLE');
      outline('13. Horquilla', 'ENABLE');
    } else if (carru == 3) {
      handleAnnot(true, 'Elevador', 'MÁSTIL DE MONTACARGAS', '1', '2', undefined);
      tweenCamera('', '14. Soporte de elevación', 1, function() {}, 0);
      outline('14. Soporte de elevación', 'ENABLE');
    } else if (carru == 4) {
      handleAnnot(true, 'Techo protector', 'Montacarga17', '1', '2', undefined);
      tweenCamera('', 'Montacarga17', 1, function() {}, 0);
      outline('Montacarga17', 'ENABLE');
    } else if (carru == 5) {
      handleAnnot(true, 'Espaldar', 'Montacarga17', '1', '2', undefined);
      tweenCamera('', 'Montacarga27', 1, function() {}, 0);
      outline('Montacarga27', 'ENABLE');
    } else if (carru == 6) {
      handleAnnot(true, 'Llantas', '7. Rueda trasera', '1', '7', undefined);
      tweenCamera('Home', '9. Cofre del motor', 1, function() {}, 0);
      outline(['Montacarga033', '7. Rueda trasera', '12. Rueda delantera (interior)', 'Montacarga31'], 'ENABLE');
    } else if (carru == 7) {
      handleAnnot(true, 'Cinturón de seguridad.', 'Montacarga17', '1', '2', undefined);
      tweenCamera('', 'Montacarga28', 1, function() {}, 0);
      outline('Montacarga28', 'ENABLE');
    } else if (carru == 8) {
      handleAnnot(true, 'Batería.', '4. Contrapeso', '1', '2', undefined);
      tweenCamera('', '4. Contrapeso', 1, function() {}, 0);
      outline('4. Contrapeso', 'ENABLE');
    } else if (carru == 9) {
      tweenCamera('SISTEMA DE ENFRIAMIENTO', '4. Contrapeso', 0.5, function() {}, 0);
      registerSetTimeout(0.8, function() {

        Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-inspeccion").style.display = "block";' + '\n' +
        '')))(appInstance, v3d, PL, VARS, PROC);

      });
    } else if (carru == 10) {

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Mostrar cuadro de niveles de fluidos y batería' + '\n' +
      'document.getElementById("cuadro-fluidos").style.display = "block";' + '\n' +
      '' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

      tweenCamera('SISTEMA DE ENFRIAMIENTO', '4. Contrapeso', 0.5, function() {}, 0);
    } else if (carru == 11) {

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('' + '\n' +
      '// Mostrar cuadro visual con imágenes' + '\n' +
      'document.getElementById("cuadro-imagenes").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 12) {
      tweenCamera('Pos etq 1', 'Plane', 0.5, function() {}, 0);

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-aceite").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 13) {
      tweenCamera('Pos etq 1', 'Plane', 0.5, function() {}, 0);

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-transmision").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 14) {
      tweenCamera('Pos etq 1', 'Plane', 0.5, function() {}, 0);

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-refrigerante").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 15) {
      tweenCamera('Pos etq 1', 'Plane', 0.5, function() {}, 0);

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-hidraulico").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 16) {

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-frenos").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else if (carru == 17) {

      Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.getElementById("cuadro-filtroaire").style.display = "block";' + '\n' +
      '')))(appInstance, v3d, PL, VARS, PROC);

    } else {
      carru = 0;
      tweenCamera('Home', '9. Cofre del motor', 1, function() {}, 0);
    }
  });
}

// Describe this function...
function izquierda() {
  carru = carru - 1;
  my_3d();
}

// Describe this function...
function derecha() {
  carru = carru + 1;
  my_3d();
}


  tweenCamera('', '6. Asiento del operador', 1, function() {}, 0);

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('app.controls.addEventListener("change", function () {' + '\n' +
  '    var raycaster = new v3d.Raycaster();' + '\n' +
  '    var downVector = new v3d.Vector3(0, -1, 0);' + '\n' +
  '    var terreno = app.scene.getObjectByName("Suelo");' + '\n' +
  '' + '\n' +
  '    if (!terreno) return;' + '\n' +
  '' + '\n' +
  '    raycaster.set(app.camera.position, downVector);' + '\n' +
  '    var intersects = raycaster.intersectObject(terreno, true);' + '\n' +
  '' + '\n' +
  '    if (intersects.length > 0) {' + '\n' +
  '        var groundY = intersects[0].point.y + 1;' + '\n' +
  '        if (app.camera.position.y < groundY) {' + '\n' +
  '' + '\n' +
  '            app.camera.position.y = v3d.MathUtils.lerp(app.camera.position.y, groundY, 0.3);' + '\n' +
  '            app.camera.updateMatrixWorld();' + '\n' +
  '        }' + '\n' +
  '    } else {' + '\n' +
  '        var newHeight = app.camera.position.y + 2;' + '\n' +
  '        app.camera.position.y = v3d.MathUtils.lerp(app.camera.position.y, newHeight, 0.3);' + '\n' +
  '        app.camera.updateMatrixWorld();' + '\n' +
  '    }' + '\n' +
  '' + '\n' +
  '});')))(appInstance, v3d, PL, VARS, PROC);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('app.controls.minDistance = 1;   // Zoom mínimo' + '\n' +
  'app.controls.maxDistance = 20;  // Zoom máximo' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('app.camera.far = 5000;' + '\n' +
  'app.camera.updateProjectionMatrix();' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('app.controls.enablePan = false;' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('app.scene.traverse(function(obj) {' + '\n' +
  '  if (obj.isMesh) {' + '\n' +
  '    obj.frustumCulled = false; // así siempre se renderiza, y la niebla no se corta bruscamente' + '\n' +
  '  }' + '\n' +
  '});' + '\n' +
  '')))(appInstance, v3d, PL, VARS, PROC);

  addFog(0.5, 0.5, 0.5, 0.005, 0, 0);


  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('var THREE = v3d;' + '\n' +
  '' + '\n' +
  'function onMouseClick(event) {' + '\n' +
  '    if (!app || !app.scene || !app.renderer || !app.camera) return;' + '\n' +
  '' + '\n' +
  '    // Obtener coordenadas ' + '\n' +
  '    var rect = app.renderer.domElement.getBoundingClientRect();' + '\n' +
  '    var mouse = new THREE.Vector2(' + '\n' +
  '        ((event.clientX - rect.left) / rect.width) * 2 - 1,' + '\n' +
  '        -((event.clientY - rect.top) / rect.height) * 2 + 1' + '\n' +
  '    );' + '\n' +
  '' + '\n' +
  '    var raycaster = new THREE.Raycaster();' + '\n' +
  '    raycaster.setFromCamera(mouse, app.camera);' + '\n' +
  '' + '\n' +
  '    // Obtener todos los objetos ' + '\n' +
  '    var objects = [];' + '\n' +
  '    app.scene.traverse(function(child) {' + '\n' +
  '        if (child.isMesh) {' + '\n' +
  '            objects.push(child);' + '\n' +
  '        }' + '\n' +
  '    });' + '\n' +
  '' + '\n' +
  '    var intersects = raycaster.intersectObjects(objects, true);' + '\n' +
  '' + '\n' +
  '    if (intersects.length > 0) {' + '\n' +
  '        var object = intersects[0].object;' + '\n' +
  '        var camPos = app.camera.position;' + '\n' +
  '        console.log(`Hiciste clic en: ${object.name}`);' + '\n' +
  '        console.log(`Posición de la cámara: X=${camPos.x.toFixed(2)}, Y=${camPos.y.toFixed(2)}, Z=${camPos.z.toFixed(2)}`);' + '\n' +
  '    }' + '\n' +
  '}' + '\n' +
  '' + '\n' +
  '// Registrar el evento de clic' + '\n' +
  'app.renderer.domElement.addEventListener(\'click\', onMouseClick, false);')))(appInstance, v3d, PL, VARS, PROC);


  registerSetTimeout(0.3, function() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info2.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info3.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info4.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info5.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info6.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info7.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', 'import (\'./js/info8.js\');')(appInstance, v3d, PL, VARS, PROC);


    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('import (\'./js/carrusel.js\');' + '\n' +
    '')))(appInstance, v3d, PL, VARS, PROC);

  });
  carru = (typeof carru === 'number' ? carru : 0) + 0;



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
